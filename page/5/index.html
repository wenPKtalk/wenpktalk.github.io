
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Summary">
    <title>Summary</title>
    <meta name="author" content="Topsion">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"http://example.com","author":{"@type":"Person","name":"Topsion","sameAs":["https://github.com/wenPKtalk","https://stackoverflow.com/users/15967860/topsion","https://www.linkedin.com/feed/"],"image":"avatar.jpg"},"name":"Summary","description":"The whole problem with the world is that fools and fanatics are always so certain of themselves, and wiser people so full of doubts.(这个世界的问题在于聪明人充满疑惑而傻子却坚信不疑)","url":"http://example.com"}</script>
    <meta name="description" content="The whole problem with the world is that fools and fanatics are always so certain of themselves, and wiser people so full of doubts.(这个世界的问题在于聪明人充满疑惑而傻子却坚信不疑)">
<meta property="og:type" content="blog">
<meta property="og:title" content="Summary">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Summary">
<meta property="og:description" content="The whole problem with the world is that fools and fanatics are always so certain of themselves, and wiser people so full of doubts.(这个世界的问题在于聪明人充满疑惑而傻子却坚信不疑)">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Topsion">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://example.com/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-yaeygdlgk8x4rqd5mp0jrkosoe3fmfokggmiu05rmpel4wjoxmvp5s6gestz.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Summary
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Topsion</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Fullstack Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/wenPKtalk"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://stackoverflow.com/users/15967860/topsion"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/feed/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/03/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2/"
                            aria-label=": 关于写博客"
                        >
                            关于写博客
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-03T21:53:50+00:00">
	
		    May 03, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E6%9D%82%E6%80%9D/">杂思</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="技术人的工作思考"><a href="#技术人的工作思考" class="headerlink" title="技术人的工作思考"></a>技术人的工作思考</h3><p>刚开始作为一个coder，可能会好奇各种各样的新技术，进而去探索，然后搁置（因为工作上可能并不会用到）。最后这些知识可能就会藏在脑海深处。</p>
<p>作为一个backend开发，我几乎学习了java周边所有的技术栈。从Java，MySQL，Redis，Spring全家桶，Kafka，K8s，Netty，，，但是说我算精通吗？我的答案是否定的。</p>
<ol>
<li>从全局看我缺乏上层架构图，将这些知识串联起来。</li>
<li>从细节看我没有对技术细节的整理输出。从而会导致捡了西瓜丢了芝麻的尴尬场面。</li>
</ol>
<h3 id="让博客成为你的学习输出"><a href="#让博客成为你的学习输出" class="headerlink" title="让博客成为你的学习输出"></a>让博客成为你的学习输出</h3><p>我层使用过各种笔记软件和博客网站：“有道云笔记”，“Enovy note”, “CSDN blog”，“博客园”，“InfoQ”等等。用了一阵后，我发现这些软件都不能让我保持专注于自己的写作，并且没有版本跟踪。而且在“种类”和“标签”检索上也没有hexo+github page这种更清爽。如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220503/22_29/image-20220503222913905.png" alt="image-20220503222913905"></p>
<h3 id="如何写好博客"><a href="#如何写好博客" class="headerlink" title="如何写好博客"></a>如何写好博客</h3><ol>
<li><p>使用markdown，这是技术人的必备第二语言。</p>
</li>
<li><p>为你的博客起一个好名字</p>
<p>为博客起一个好名字，更能让你再接下来复盘的时候检索到你这篇博客的目的。所以你的博客名字最好有总结性。</p>
</li>
<li><p>博客段落设置</p>
<ul>
<li>解释这篇博客包含哪些内容</li>
<li>切入主题，分1，2，3带上配图</li>
<li>总结</li>
</ul>
</li>
<li><p>技术是不断迭代的，记得一定要维护你的博客跟上技术更新的步骤。</p>
</li>
</ol>
<h3 id="持之以恒"><a href="#持之以恒" class="headerlink" title="持之以恒"></a>持之以恒</h3><p>好记性不如烂笔头，只有自己的记录才最靠谱。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/03/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/26/Spring-%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E4%B9%8B%E4%B8%80/"
                            aria-label=": Spring 事务注解失效之一"
                        >
                            Spring 事务注解失效之一
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-26T14:59:01+00:00">
	
		    Nov 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Spring/">Spring</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>​    Spring针对事务的管理是通过动态代理实现的，<strong>那么事务要进行传播首先必须要是被代理的方法之间</strong>，这是Spring事务传播的前提。比如：如果在同一个service里两个方法：方法A，方法B上都加了Transactional()</p>
<p>并且用方法A直接调用了方法B此时方法B上的注解Transactional并不生效（具体原因会新增文章说明跟动态代理的机制有关）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span>&#123;</span><br><span class="line">    <span class="comment">//方法A</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)</span></span><br><span class="line">    a()&#123;</span><br><span class="line">        ...</span><br><span class="line">        b();<span class="comment">//此时b方法上添加的事务注解并不生效</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方法B</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)</span></span><br><span class="line">    b()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务传播生效示例"><a href="#事务传播生效示例" class="headerlink" title="事务传播生效示例"></a>事务传播生效示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line">    <span class="comment">//方法A</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED,rollbackFor = Exception.class)</span></span><br><span class="line">    a()&#123;</span><br><span class="line">        ...</span><br><span class="line">        classB.c();<span class="comment">//此时c方法上添加的事务注解会生效</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//方法B</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)</span></span><br><span class="line">    b()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span>&#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)</span></span><br><span class="line">    c()&#123;</span><br><span class="line">        ...</span><br><span class="line">       c();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring 事务传播属性对比</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
<th align="left">对比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PROPAGATION_REQUIRED</td>
<td align="left">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择，默认选择。</td>
<td align="left">常用的</td>
</tr>
<tr>
<td align="left">PROPAGATION_SUPPORTS</td>
<td align="left">支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">PROPAGATION_MANDATORY</td>
<td align="left">使用当前的事务，如果当前没有事务，就抛出异常。</td>
<td align="left">当业务方法被设置为PROPAGATION_MANDATORY时，它就不能被非事务的业务方法调用。如将ClassB.c() 设置为PROPAGATION_MANDATORY，如果展现层的Action直接调用c()方法，将引发一个异常。正确的情况是： <br/>c()方法必须被另一个带事务的业务方法调用比如示例2。  PROPAGATION_MANDATORY的方法一般都是被其它业务方法间接调用的。</td>
</tr>
<tr>
<td align="left">PROPAGATION_REQUIRES_NEW</td>
<td align="left">新建事务，如果当前存在事务，把当前事务挂起。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">PROPAGATION_NOT_SUPPORTED</td>
<td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
<td align="left">当方法被设置为PROPAGATION_NOT_SUPPORTED时，外层业务方法的事务会被挂起，当内部方法运行完成后，外层方法的事务重新运行。如果外层方法没有事务，直接运行，不需要做任何其它的事。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NEVER</td>
<td align="left">以非事务方式执行，如果当前存在事务，则抛出异常。</td>
<td align="left">当业务方法被设置为PROPAGATION_NEVER时，它将不能被拥有事务的其它业务方法调用。假设ClassB.c() <br/>()设置为PROPAGATION_NEVER，当Class.a()拥有一个事务时，c()方法将抛出异常。所以PROPAGATION_NEVER方法一般是被直接调用的如示例1。</td>
</tr>
<tr>
<td align="left">PROPAGATION_NESTED</td>
<td align="left">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
<td align="left">PROPAGATION_NESTED和PROPAGATION_REQUIRES_NEW的区别在于：PROPAGATION_REQUIRES_NEW 启动一个新的、和外层事务无关的“内部”事务。该事务拥有自己的独立隔离级别和锁，不依赖于外部事务，独立地提交和回滚。当内部事务开始执行时，外部事务 将被挂起，内务事务结束时，外部事务才继续执行。将创建一个全新的事务，它和外层事务没有任何关系.而 PROPAGATION_NESTED 将创建一个依赖于外层事务的子事务，当外层事务提交或回滚时，子事务也会连带提交和回滚。</td>
</tr>
</tbody></table>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/26/Spring-%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E4%B9%8B%E4%B8%80/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/30/%E5%90%8E%E7%AB%AF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"
                            aria-label=": 后端问题排查常用命令"
                        >
                            后端问题排查常用命令
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-30T21:09:55+00:00">
	
		    Apr 30, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/DevOps/">DevOps</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="linux篇"><a href="#linux篇" class="headerlink" title="linux篇"></a>linux篇</h3><h4 id="资源查看"><a href="#资源查看" class="headerlink" title="资源查看"></a>资源查看</h4><ol>
<li><p>查看内存剩余空间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">free -m -s 2 -c 20 -t  <span class="comment"># 内存剩余空间 以M为输出，两秒更新一次，更新20次</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          62838       35817        7814       13366       19206       13099</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">Total:        62838       35817        7814</span><br></pre></td></tr></table></figure></li>
<li><p>查看nginx中生效的conf文件所在目录(docker 需s要进入容器)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -t </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure></li>
<li><p>查看磁盘空间大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h <span class="comment"># -h: human缩写，以易读的方式显示结果（即带单位：比如M/G，如果不加这个参数，显示的数字以B为单位）</span></span><br><span class="line"><span class="built_in">df</span> -i： 以inode模式来显示磁盘使用情况，显示inode信息而非块使用量。</span><br><span class="line"><span class="built_in">df</span> --total：显示所有的信息。</span><br><span class="line"></span><br><span class="line"><span class="comment">#/opt/app/todeav/config#df -h</span></span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00</span><br><span class="line">2.0G  711M  1.2G  38% /</span><br><span class="line">/dev/mapper/vg1-lv2    20G  3.8G   15G  21% /opt/applog</span><br><span class="line">/dev/mapper/vg1-lv1    20G   13G  5.6G  70% /opt/app</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看当前目录所占空间大小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">du -sh  # -h 人性化显示 -s 递归整个目录的大小</span><br><span class="line">du -ah： 显示目录，其下目录和文件占用的磁盘空间大小，带单位。</span><br><span class="line">du -c： 显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和。</span><br><span class="line">du -sh： 查看当前目录总共占的容量，而不单独列出各子项占用的容量。</span><br><span class="line">du -l：在统计目录占用磁盘空间大小时，把硬链接也统计进来。</span><br><span class="line">du -lh --max-depth=1：查看当前目录下一级子文件和子目录占用的磁盘容量。</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前目录下所有子文件夹排序后的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh `ls` | sort  # 注意不是单引号`</span><br></pre></td></tr></table></figure></li>
<li><p>内存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br><span class="line">free -h：显示内存状态。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf etc.tar /etc <span class="comment"># 仅打包，不压缩！-c :打包选项 -v :显示打包进度 -f :使用档案文件</span></span><br></pre></td></tr></table></figure>



<h3 id="docker-篇"><a href="#docker-篇" class="headerlink" title="docker 篇"></a>docker 篇</h3><ol>
<li><p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it [containerId|serviceName] /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>查看运行容器资源占用情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats [contatinerId|serviceName]</span><br></pre></td></tr></table></figure></li>
<li><p>查看容器内日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -n 100 [contatinerId|serviceName] | grep -n10 &#x27;ERROR&#x27; #输出容器运行日志，使用grep查找关键字后10行内容</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝容器里的文件到本地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp contatinerId:/tmp   /home/tmp</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li>dump docker中</li>
</ol>
<h3 id="Java-常用排查工具"><a href="#Java-常用排查工具" class="headerlink" title="Java 常用排查工具"></a>Java 常用排查工具</h3><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>官网连接：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/#monitor">https://docs.oracle.com/javase/8/docs/technotes/tools/#monitor</a></p>
<blockquote>
<p>jstat 工具允许以固定的监控频次输出JVM的各种监控指标，比如使用-gcutil输出GC和内存占用汇总信息，每隔5秒输出一次，输出100次，可以看到Young GC比较频繁：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil [pid] [毫秒次]  [多少次]</span><br><span class="line"></span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00   0.00   8.00   0.00  17.91  20.19      0    0.000     0    0.000    0.000</span><br><span class="line">  0.00   0.00   8.00   0.00  17.91  20.19      0    0.000     0    0.000    0.000</span><br><span class="line">  0.00   0.00   8.00   0.00  17.91  20.19      0    0.000     0    0.000    0.000</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 其中，S0 表示 Survivor0 区占用百分比，S1 表示 Survivor1 区占用百分比，E 表示 Eden 区占用百分比，O 表示老年代占用百分比，M 表示元数据区占用百分比，YGC 表示年轻代回收次数，YGCT 表示年轻代回收耗时，FGC 表示老年代回收次数，FGCT 表示老年代回收耗时。</p>
</blockquote>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>将输出的线程栈导入<a target="_blank" rel="noopener" href="https://fastthread.io/">https://fastthread.io/</a> 进行可视化分析</p>
<h3 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h3><p><a target="_blank" rel="noopener" href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">Linux Tools Quick Tutorial</a> </p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/">Docker 命令实战</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/30/%E5%90%8E%E7%AB%AF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/13/%E8%AE%A4%E8%AF%86java-util-concurrent%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"
                            aria-label=": 认识java.util.concurrent中的工具类"
                        >
                            认识java.util.concurrent中的工具类
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-13T21:00:17+00:00">
	
		    Mar 13, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Concurrency/">Concurrency</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="一-同步结构"><a href="#一-同步结构" class="headerlink" title="一. 同步结构"></a>一. 同步结构</h3><p>提供了比synchronized更加高级的同步结构：countDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作。</p>
<ol>
<li><p>Semaphore：作为资源控制器限制同时进行工作的线程数量，java版本的信号量实现。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wenPKtalk/mutithread/blob/master/src/main/java/current_demo/AbnormalSemaphoreSample.java">通过Semaphore实现车站调度demo</a></p>
</li>
<li><p>CountDownLatch：允许一个或者多个线程等待某些操作完成。</p>
</li>
<li><p>CyclicBarrier：一种辅助性的同步结构，语序多个线程等待到达某个屏障。</p>
<p>CountDownLatch和CyclicBarrier的区别：</p>
<p>i. CountDownLatch是不可以重置，所以无法重用，而CyclicBarrier则没有这种限制，可以重用。</p>
<p>ii. CountDownLatch的基本操作组合是countDown/await。调用await的线程阻塞等待countDown足够的次数，不管你是在一个线程还是多个线程里countDown,只要次数足够即可。CountDownLatch操作的是事件。</p>
<p>iii. CyclicBarrier的基本操作组合，则就是await,当所有的伙伴（parties）都调用了await,才会继续进行任务，并自动进行重置。注意，正常情况下，CyclicBarrier的重置都是自动发生的，如果我们调用reset方法，单还有线程在等待，就会导致等待线程发生干扰，抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件， <strong>它的典型应用场景是用来等待并发线程结束。</strong></p>
</li>
</ol>
<h3 id="二-线程安全容器"><a href="#二-线程安全容器" class="headerlink" title="二. 线程安全容器"></a>二. 线程安全容器</h3><p><strong>java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent*、CopyOnWrite和 Blocking</strong></p>
<p><strong>Map形式的：</strong></p>
<ol>
<li><p>ConcurrentHashMap：jdk8以前使用分段锁，jdk8后采用CAS</p>
</li>
<li><p>ConcunrrentSkipListMap：</p>
</li>
<li><p>ConcurrentSkipListMap：是TreeMap的线程安全版本。</p>
</li>
</ol>
<p><strong>List形式的：</strong></p>
<p>CopyOnWriteArrayList：通过快照实现，适用于读多写少的场景。在对其实例进行修改操作（add/remove等）会新建一个数据并修改，修改完毕之后，再将原来的引用指向新的数组。</p>
<p><strong>Set形式的：</strong></p>
<p>CopyOnWriteArraySet：同上CopyOnWriteArrayList</p>
<p><strong>Queue形式的：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220420/23_34/Queue%E7%B1%BB%E5%9B%BE.jpg" alt="Queue类图" style="zoom:50%;" />

<p>ArrayBlockQueue: 有界队列，需要显示的指定队列大小</p>
<p>LinkedBlockQueue: 被认为无界，其实有</p>
<p><strong>我在介绍 ReentrantLock 的条件变量用法的时候分析过 ArrayBlockingQueue，不知道你有没有注意到，其条件变量与 LinkedBlockingQueue 版本的实现是有区别的。notEmpty、notFull 都是同一个再入锁的条件变量，而 LinkedBlockingQueue 则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。</strong>  — 引用</p>
<p>PriorityBlockQueue: 无边界的优先级队列</p>
<h3 id="三-强大的Executor框架"><a href="#三-强大的Executor框架" class="headerlink" title="三. 强大的Executor框架"></a>三. 强大的Executor框架</h3><ol>
<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li>
<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>
<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建。</li>
</ol>
<h3 id="四-框架图"><a href="#四-框架图" class="headerlink" title="四. 框架图"></a>四. 框架图</h3><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220420/23_34/%E5%B9%B6%E5%8F%91%E5%9B%BE%E8%B0%B1.jpg" alt="并发图谱" style="zoom:50%;" />

<h3 id="参考作品"><a href="#参考作品" class="headerlink" title="参考作品"></a>参考作品</h3><p>《Java Core 卷一》</p>
<p>JUC常用4大并发工具类 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Ixz8V0oMHyRvCzJ3EsZkFA">https://mp.weixin.qq.com/s/Ixz8V0oMHyRvCzJ3EsZkFA</a></p>
<p>Java并发干货 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Sxnf5teW1vehkhBfkV7E-g">https://mp.weixin.qq.com/s/Sxnf5teW1vehkhBfkV7E-g</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/13/%E8%AE%A4%E8%AF%86java-util-concurrent%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/03/%E7%AF%87%E7%AB%A04-MySQL%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89/"
                            aria-label=": 篇章4-MySQL索引（一）"
                        >
                            篇章4-MySQL索引（一）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-03T09:57:59+00:00">
	
		    Dec 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Mysql/">Mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p> 经常听到别人讲数据库就像书的目录一样，是为了提高查询效率，那么索引实现和书的目录区别又是什么？</p>
</blockquote>
<h3 id="一、索引的常见模型"><a href="#一、索引的常见模型" class="headerlink" title="一、索引的常见模型"></a>一、索引的常见模型</h3><ol>
<li>哈希表</li>
<li>有序数组</li>
<li>搜索树（<strong>InnoDB采用的是N叉B+树InnoDB引擎使用的数据结构后边重点介绍</strong>）<br><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220413/22_59/1384695-20181210215947282-1781397207.png" alt="img"></li>
</ol>
<h3 id="二、各模型分析"><a href="#二、各模型分析" class="headerlink" title="二、各模型分析"></a>二、各模型分析</h3><h5 id="1-哈希表模型图解"><a href="#1-哈希表模型图解" class="headerlink" title="1. 哈希表模型图解"></a>1. 哈希表模型图解</h5><p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220413/22_59/1384695-20181210220024095-1874773450.png" alt="img"></p>
<p>如图所示：跟java中的hashMap数据结构一致</p>
<blockquote>
<ol>
<li>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</li>
<li>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</li>
<li>你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用户，就必须全部扫描一遍了。<br>由上可以推断：哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</li>
</ol>
</blockquote>
<h5 id="2-有序数组模型图解（等值查询和区间查询效率都很高）"><a href="#2-有序数组模型图解（等值查询和区间查询效率都很高）" class="headerlink" title="2. 有序数组模型图解（等值查询和区间查询效率都很高）"></a>2. 有序数组模型图解（等值查询和区间查询效率都很高）</h5><p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220413/23_00/1384695-20181210221413226-1135037815.png" alt="img"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ol>
<li>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。</li>
<li>同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。如果仅仅看查询效率，有序数组就是最好的数据结构了。<br><strong>缺点：</strong><br>但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。有序数组索引只适用于静态存储引擎。</li>
</ol>
</blockquote>
<h5 id="3-二叉搜索树模型图解（等值查询和区间查询效率都很高）"><a href="#3-二叉搜索树模型图解（等值查询和区间查询效率都很高）" class="headerlink" title="3. 二叉搜索树模型图解（等值查询和区间查询效率都很高）"></a>3. 二叉搜索树模型图解（等值查询和区间查询效率都很高）</h5><p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220413/23_00/1384695-20181210222604489-96063926.png" alt="img"></p>
<p><strong>优点：</strong></p>
<blockquote>
<ol>
<li>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</li>
<li>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的</li>
</ol>
</blockquote>
<p><strong>缺点：</strong><br>但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p>
<h5 id="4-N叉B-树（N差不多是1200）"><a href="#4-N叉B-树（N差不多是1200）" class="headerlink" title="4. N叉B+树（N差不多是1200）"></a>4. N叉B+树（N差不多是1200）</h5><blockquote>
<ol>
<li>每一个索引在InnoDB中都是一棵B+树</li>
<li>这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</li>
</ol>
</blockquote>
<h3 id="三、InnoDB索引模型案例分析"><a href="#三、InnoDB索引模型案例分析" class="headerlink" title="三、InnoDB索引模型案例分析"></a>三、InnoDB索引模型案例分析</h3><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create table</span> T(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary key</span>, </span><br><span class="line">k <span class="type">int</span> <span class="keyword">not null</span>, </span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k))engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。<br><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220413/23_00/1384695-20181210222643511-541601281.png" alt="img"></p>
<ol>
<li>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引（clustered index）</strong>。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary index）</strong>。<br>基于主键索引和普通索引的查询有什么区别？</li>
</ol>
<ul>
<li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。<br>也就是说，<strong>基于非主键索引的查询需要多扫描一棵索引树</strong>（回表）<strong>。因此，我们在应用中应该尽量使用主键查询</strong>。</li>
</ul>
<h3 id="四、InnoDB索引维护"><a href="#四、InnoDB索引维护" class="headerlink" title="四、InnoDB索引维护"></a>四、InnoDB索引维护</h3><ol>
<li>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</li>
<li>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</li>
<li>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</li>
<li>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</li>
<li>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该？</li>
</ol>
<blockquote>
<ol>
<li>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</li>
<li>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</li>
<li>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li>
<li>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</li>
<li>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</li>
<li>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</li>
<li>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</li>
<li>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</li>
</ol>
</blockquote>
<p>6.有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：<br>只有一个索引；该索引必须是唯一索引。<br>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/03/%E7%AF%87%E7%AB%A04-MySQL%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/01/%E7%AF%87%E7%AB%A03-MySql%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A2%E7%A9%B6/"
                            aria-label=": 篇章3-MySql的事务探究"
                        >
                            篇章3-MySql的事务探究
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-01T22:48:53+00:00">
	
		    Dec 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Mysql/">Mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h5 id="一-ACID解释"><a href="#一-ACID解释" class="headerlink" title="一. ACID解释"></a>一. ACID解释</h5><p>A: Atomicity 原子性<br>C: Consistencey 一致性<br>I: Isolation 一致性<br>D: Durability 持久性</p>
<h5 id="二-事务隔离级别"><a href="#二-事务隔离级别" class="headerlink" title="二. 事务隔离级别"></a>二. 事务隔离级别</h5><ol>
<li>读未提交（read uncommited）一个事务还未提交，它的更改可以被其他事务读到。</li>
<li>读提交（read commited）只有一个事务提交了后，它的更改才可以被其他事务读到。</li>
<li>可重复读（repeatable read）一个事务执行过程中看到的数据，总是跟这个事务启动前看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化（serializable）对于同一行记录，读会加读锁，写会加写锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成。</li>
</ol>
<p><em>知识点</em> 读提交和可重复读的区别是：有两个事务A,B。读提交是：如果A事务在开启过程中，B事务对记录进行了更改并且提交了，A是可以读到的B事务更改后的记录。可重复读则是：就算A事务在开启过程中B事务对记录进行了更改并且提交了，A也是读不到B更改后的记录。A事务仍然读到的事它开启时记录最初的状态。只有当A事务进行提交后才能读到B更改后的记录。</p>
<p><em>Oracle默认的隔离级别是读提交</em><br>配置的方式是，将启动参数 transaction-isolation 的值设置成READ-COMMITTED。你可以用 show variables 来查看当前的值。</p>
<p><strong>可重复读的应用场景</strong></p>
<blockquote>
<p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p>
</blockquote>
<h5 id="三-事务隔离实现为什么要避免大量的大事务"><a href="#三-事务隔离实现为什么要避免大量的大事务" class="headerlink" title="三. 事务隔离实现为什么要避免大量的大事务"></a>三. 事务隔离实现为什么要避免大量的大事务</h5><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220413/22_52/d9c313809e5ac148fc39feff532f0fee.png" alt="img"></p>
<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p>
<p>当系统里没有比这个回滚日志更早的 read-view 的时候才删除日志。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。<br>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。<br>在工作中有的公司代码中可能采用的AOP来进行事务管理，根据service层入口的方法名前缀来判断是否开启事务，经常能看到有的开发者为了不必要的麻烦所有都采用了开启事务，这是不合理的。</p>
<p>问题：如何避免长事务对业务的影响？</p>
<blockquote>
<p><strong>首先，从应用开发端来看：</strong></p>
<ol>
<li>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li>
<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）  </li>
</ol>
<p><strong>其次，从数据库端来看：</strong></p>
<ol>
<li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</li>
<li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</li>
<li>如果使用的是 MySQL  5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ol>
</blockquote>
<blockquote>
<p>阅读《MySQL实战45讲》</p>
</blockquote>
<blockquote>
<p>InnoDB的undo log文件存储在MySQL数据目录下的ibdata文件中，这个文件包含了多种不同的数据结构和信息，其中包括了InnoDB的undo log。</p>
<p>具体来说，每个InnoDB表都有一个undo log，用于记录对该表进行的事务操作，如INSERT、UPDATE和DELETE。当需要回滚一个事务时，InnoDB会使用undo log中的信息来撤消该事务所做的更改。</p>
<p>在默认情况下，InnoDB的undo log被存储在ibdata文件的系统表空间中。如果使用了多个独立的表空间，每个表空间也会包含一个undo段，其中包含与该表空间关联的所有表的undo log。</p>
<p>值得注意的是，如果启用了innodb_undo_tablespaces选项，每个InnoDB表将会有一个独立的undo表空间文件，这些文件将会存储在指定的目录中，而不是在ibdata文件中。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/01/%E7%AF%87%E7%AB%A03-MySql%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A2%E7%A9%B6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/26/%E7%AF%87%E7%AB%A02-MySql%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97redolog%E5%92%8Cbinlog/"
                            aria-label=": 篇章2-MySql两个重要的日志redolog和binlog"
                        >
                            篇章2-MySql两个重要的日志redolog和binlog
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-26T16:46:43+00:00">
	
		    Nov 26, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Mysql/">Mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>一句update的语句：Update T set C=c+1 where id = 2;</p>
</blockquote>
<p>和查询语句一样会走一遍如下的流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220412/17_00/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbnBlbmcxMg==,size_16,color_FFFFFF,t_70.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>与查询语句不一样的是，更新语句设计上有两个重要的模块：redo log 和 binlog</strong></p>
<h3 id="一、重要日志模块-redo-log-InnoDB引擎特有的日志"><a href="#一、重要日志模块-redo-log-InnoDB引擎特有的日志" class="headerlink" title="一、重要日志模块: redo log InnoDB引擎特有的日志"></a>一、重要日志模块: redo log InnoDB引擎特有的日志</h3><p>Write-Ahead Logging（WAL技术）它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<ol>
<li><p>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写入到redo log（粉板）理。</p>
</li>
<li><p>进行内存的更新。</p>
<p>以上两步操作后更新就算完成了。</p>
</li>
<li><p>同时InnoDB引擎会在适当的时候将这个操作记录更新到磁盘里面。而这个更新往往是系统比较空闲的时候。类比掌柜下班后将粉板上的赊账记录誊写到账本上，</p>
</li>
</ol>
<p>但是：如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220412/17_05/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbnBlbmcxMg==,size_16,color_FFFFFF,t_70-20220412170519468.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ol>
<li><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
</li>
<li><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
</li>
<li><p>crash-safe：有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。</p>
</li>
</ol>
<h3 id="二、重要日志模块-binlog-server层归档日志"><a href="#二、重要日志模块-binlog-server层归档日志" class="headerlink" title="二、重要日志模块: binlog server层归档日志"></a>二、重要日志模块: binlog server层归档日志</h3><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>
<h3 id="三、redo-log-和-binlog的差异："><a href="#三、redo-log-和-binlog的差异：" class="headerlink" title="三、redo log 和 binlog的差异："></a>三、redo log 和 binlog的差异：</h3><ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<h3 id="四、update语句执行流程："><a href="#四、update语句执行流程：" class="headerlink" title="四、update语句执行流程："></a>四、update语句执行流程：</h3><ol>
<li><p>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220412/17_04/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbnBlbmcxMg==,size_16,color_FFFFFF,t_70-20220412170428798.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”.</p>
<h3 id="五、两阶段提交："><a href="#五、两阶段提交：" class="headerlink" title="五、两阶段提交："></a>五、两阶段提交：</h3><p>怎样让数据库恢复到半个月内任意一秒的状态？</p>
<ol>
<li><p>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</p>
</li>
<li><p>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</p>
<p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
</li>
</ol>
<p>&gt;阅读《MySQL实战45讲》</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/26/%E7%AF%87%E7%AB%A02-MySql%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97redolog%E5%92%8Cbinlog/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/25/%E7%AF%87%E7%AB%A01-MySql%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"
                            aria-label=": 篇章1-MySql架构基础及执行引擎"
                        >
                            篇章1-MySql架构基础及执行引擎
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-25T16:35:40+00:00">
	
		    Nov 25, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Mysql/">Mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="MySQL的架构示意："><a href="#MySQL的架构示意：" class="headerlink" title="MySQL的架构示意："></a>MySQL的架构示意：</h3><p><img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220412/16_39/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p>
<blockquote>
<p>MySQL大体分为两层：Server 层和存储引擎层</p>
<blockquote>
<ol>
<li>server层: 连接器，查询缓存，分析器，优化器等，涵盖MySQL的大多数核心服务功能，一级所有内置函数（如日期，时间，数学和加密函数等），所有夸存储引起的功能都在这一层实现，比如：存过，触发器，视图等。</li>
<li>存储引擎负责数据的存储和提取：innoDB,MyISAM,Memory等 MySql5.5.5版本开始默认为InnoDB</li>
</ol>
</blockquote>
</blockquote>
<h3 id="个层次分工："><a href="#个层次分工：" class="headerlink" title="个层次分工："></a>个层次分工：</h3><ol>
<li>连接器：顾名思义连接器负责跟客户端建立连接、获取权限、维持和管理连接<br>你可以在 show processlist 命令中看到它。Command列显示为Sleep则表示该连接为空闲链接。  </li>
<li>查询缓存：连接建立完成后，你就可以执行 select 语句了。执行逻辑第二步查询缓存。<br>优势：提高查询效率，适合表数据不经常做更新的。<br>劣势：一张表有更新机会清空缓存，命中率会很低。<br>使用参数 query_cache_type 设置成 DEMAND这样对应默认的SQL语句是不适用查询缓存的，显示指定的时候才会查询缓存如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> ID <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li>分析器：如果没有命中缓存则开始对SQL语句进行解析，生成解析树。</li>
<li>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前得经过优化器的处理，包括表里有多个索引时决定使用哪个索引；一个语句有多表关联的时候决定各个表的连接顺序；<br>比如：<blockquote>
<p>mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;  </p>
<ol>
<li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于20。</li>
<li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值,再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是是否等于 10。</li>
</ol>
</blockquote>
</li>
</ol>
<p><em>后边仔细分析对索引的选择</em><br>5. 执行器：MySql通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了之情器阶段开始执行语句。<br>如以下语句的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行器会根据表定义的引擎取调用这个引擎所提供的接口。比如我们例句中提供的表T，ID无索引则会：  </p>
<blockquote>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID是否为10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，指导取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足的条件行组成记录集作为结果返回给客户端。</li>
</ol>
</blockquote>
<p>至此这个语句执行就完成了。<br>对于有索引的表，执行的逻辑也差不多。第一次调用的是<strong>“满足条件得第一行“这个接口，之后循环取“满足条件的下一行”这个接口。</strong> 这些接口都是存储殷勤中定义好的。<br>** rows_examined **：表示语句扫描了多少行，这个值就是执行器每次调用引擎获取数据行时累加的。<br><strong>在某些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined（调用次数可能小于扫描行数）并不是完全相同的</strong></p>
<blockquote>
<p>阅读《MySQL实战45讲》</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/25/%E7%AF%87%E7%AB%A01-MySql%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/24/Java%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/"
                            aria-label=": Java问题收集"
                        >
                            Java问题收集
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-24T23:41:04+00:00">
	
		    May 24, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li>谈谈你对java体系的理解？“java是解释执行”，这句话是正确的吗？  </li>
</ol>
<blockquote>
<p>java底层有jvm（java虚拟机）来兼容不同的操作系统，java运行前会编译成jvm可以识别的字节码我们常说的class文件，然后由jvm来解释执行。</p>
</blockquote>
<ol start="2">
<li>请对比Exception和Error，运行时异常与一般异常有什么区别？  </li>
</ol>
<blockquote>
<p>Error ：表示由 JVM 所侦测到的无法预期的错误，由于这是属于 JVM 层次的严重错误 ，导致 JVM 无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。（IOException,SqlException）<br>Exception ：表示可恢复的例外，这是可捕捉到的。(NullPointerException)</p>
</blockquote>
<p>  <img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220420/23_44/accba531a365e6ae39614ebfa3273900.png" alt="img"></p>
<ol start="3">
<li>谈谈final,finally,finalize有什么不同？  </li>
</ol>
<blockquote>
<p>final: 修饰变量表示为常量，修饰方法不能被子类重写，修饰类不能被继承。<br>finally: 捕获异常后始终会执行 finally中的代码块。<br>finalize: 释放需要被回收的对象</p>
</blockquote>
<ol start="4">
<li>强引用，软引用，弱引用有什么区别？具体使用场景是什么？  </li>
</ol>
<blockquote>
<ol>
<li>强引用：（最常用）<br>String str = “abc”;<br>list.add(str);<br>当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误    </li>
<li>软引用：<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。<br>如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象   </li>
<li>弱引用：   WeakReference<br>如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象 </li>
<li>虚引用：<br>虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s = “abc”;如果没有对象回收了， 就回收没虚引用的对象</li>
</ol>
</blockquote>
<p>  <img src="https://cdn.jsdelivr.net/gh/wenPKtalk/pictures@master/blog/20220420/23_45/36d3c7b158eda9421ef32463cb4d4fb0.png" alt="img"></p>
<ol start="5">
<li>理解java字符串，String，StringBuffer，StringBuilder有什么区别？  </li>
</ol>
<blockquote>
<ol>
<li>可变性<br>  String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。<br>  StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。  </li>
<li>线程安全性<br>  StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。<br>性能<br>  每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。<br>对于三者使用的总结：<br>如果要操作少量的数据用 = String<br>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer  </li>
</ol>
</blockquote>
<ol start="6">
<li>谈谈java反射机制，动态代理是基于什么原理？  </li>
</ol>
<blockquote>
<p>代理模式是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个真实对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/scplove/article/details/52451899">动态代理详解链接</a></p>
</blockquote>
<ol start="7">
<li>int和Integer有什么区别？Integer值的缓存范围是什么？  </li>
</ol>
<blockquote>
<p>（1）Integer是int的包装类；int是基本数据类型；<br>（2）Integer变量必须实例化后才能使用；int变量不需要；<br>（3）Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；<br>（4）Integer的默认值是null；int的默认值是0。<br>Integer值的缓存范围是：-128-127<br>JVM会自动维护八种基本类型的常量池，int常量池中初始化-128<del>127的范围，所以当为Integer i=127时，在自动装箱过程中是取自常量池中的数值，而当Integer i=128时，128不在常量池范围内，所以在自动装箱过程中需new 128，所以地址不一样。<br>a.当数值范围为-128</del>127时：如果两个new出来Integer对象，即使值相同，通过“==”比较结果为false，但两个对象直接赋值，则通过“==”比较结果为“true，这一点与String非常相似。<br>b.当数值不在-128~127时，无论通过哪种方式，即使两个对象的值相等，通过“==”比较，其结果为false；<br>c.当一个Integer对象直接与一个int基本数据类型通过“==”比较，其结果与第一点相同；<br>d.Integer对象的hash值为数值本身；  </p>
</blockquote>
<ol start="8">
<li>对比Vector,ArrayList,LinkedList有何区别？  </li>
</ol>
<blockquote>
<p>vector线程同步。<br>ArrayList 底层为线性表，线程非同步。获取数据很方便，插入删除，比较耗性能。<br>LinkedList 底层为链表所以获取数据性能较差，删除，插入数据方便。<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5a99544ef265da23a334ab6c">集合面试指南</a>  </p>
</blockquote>
<ol start="9">
<li>对比Hashtable,HashMap,TreeMap,谈谈你对HashMap的掌握？  </li>
</ol>
<blockquote>
<p>答案同上链接  </p>
</blockquote>
<ol start="10">
<li>如何保证集合是线程安全的？ConcurrentHashMap做了什么？  </li>
</ol>
<blockquote>
<p>答案同上链接  </p>
</blockquote>
<ol start="11">
<li><p>java NIO提供了哪些IO方式？看过NIO的源代码吗？如果让你来改进NIO，会做什么改进？</p>
<blockquote>
<p>后续 出文章讲</p>
</blockquote>
</li>
<li><p>面向对象中的抽象类，接口的区别是什么？    </p>
</li>
</ol>
<blockquote>
<p>1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法<br>2.接口中的实例变量默认是final类型的，而抽象类中则不一定<br>3.一个类可以实现多个接口，但最多只能实现一个抽象类<br>4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定<br>5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象<br>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
</blockquote>
<ol start="13">
<li>说说你知道的设计模式？请动手实现单例模式，Spring，Mybatis使用了哪些设计模式？  </li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/f-sJIZHr7JUa31gKTllSFQ">单例模式整合链接</a></p>
</blockquote>
<ol start="14">
<li>理解java的锁实现，Synchronized和ReentrantLock有什么区别？有人说Synchronized最慢，这句话靠谱吗？  </li>
</ol>
<blockquote>
<p>上网搜搜，能吹出来就行。</p>
</blockquote>
<ol start="15">
<li><p>一个线程连着调用start()两次会出现什么情况？谈谈线程的生命周期和状态转移。</p>
</li>
<li><p>什么情况下java程序会产生死锁？如何排除？<br>比较基础，产生对临界资源的竞争。   </p>
</li>
<li><p>java并发包提供了哪些并发类？使用这些数据结构解决过什么并发问题？</p>
</li>
<li><p>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</p>
</li>
<li><p>java并发类库提供的线程池有哪几种？如何选择？  </p>
</li>
<li><p>什么是类加载过程，双亲委派模型？</p>
</li>
<li><p>谈谈jvm内存区域划分，如何监控和诊断jvm堆内和堆外内存使用？COM常见排查思路有哪些？</p>
</li>
<li><p>GC收集器有哪些？常见的调优方法有哪些？</p>
</li>
<li><p>谈谈java内存模型（JMM)，原子性，可见性，有序性是什么？volatile的理解。<br>记住jmm内存模型很容易理解<br><a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=8832a0433d1908f9e08cc93f6f1bb5bf">答案分析链接</a></p>
</li>
<li><p>AOP是什么解决了什么问题？  </p>
</li>
</ol>
<blockquote>
<p>切面编程可以将公共代码提取出来，减少业务代码侵入比如权限校验，日志处理等。<br>几个比较重要的词汇：<br>Joinpoint(连接点): 类里面可以被增强的方法，这些方法称为连接点</p>
</blockquote>
<blockquote>
<p>Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义.</p>
</blockquote>
<blockquote>
<p>Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</p>
</blockquote>
<blockquote>
<p>Aspect(切面): 是切入点和通知（引介）的结合</p>
</blockquote>
<blockquote>
<p>Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.<br>Target(目标对象):代理的目标对象(要增强的类)</p>
</blockquote>
<blockquote>
<p>Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程</p>
</blockquote>
<blockquote>
<p>Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类</p>
</blockquote>
<ol start="25">
<li>mybatis实现二级缓存  </li>
</ol>
<blockquote>
<p>Mybatis的二级缓存配置相当容易，要开启二级缓存，只需要在你的Mapper<br>映射文件中添加一行：<br><cache /><br>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。这里我主要介绍整合EhCache  </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19816777/article/details/61662761">Mybatis实现二级缓存解析</a><br>26.大数据相关<br>Hadoop,spak,Hbase,Hive这些东西各自是干嘛的了解，了解。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/24/Java%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/page/4/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 5 of 5</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Topsion. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Topsion</h4>
        
            <div id="about-card-bio"><p>Fullstack Developer</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Coder</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Xi&#39;an China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-q2wtdh1f7oaxzdmuuvsc1uyl8fnwcg5dz7kgztdayssvj6qd6o7u5zwralwk.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
